#!/usr/bin/env python3
"""
Módulo de Detecção de Vulnerabilidades
Scanner avançado para identificação de vulnerabilidades conhecidas
"""

import subprocess
import json
import re
import requests
import threading
from concurrent.futures import ThreadPoolExecutor
import time
import random
from datetime import datetime

class VulnerabilityScanner:
    """
    Scanner avançado de vulnerabilidades usando nmap NSE e bases de dados CVE
    """
    
    def __init__(self, logger=None):
        self.logger = logger
        self.vulnerability_results = {}
        self.cve_database = {}
        
        # Scripts NSE de vulnerabilidades organizados por categoria
        self.vulnerability_scripts = {
            'critical': [
                'smb-vuln-ms17-010',  # EternalBlue
                'smb-vuln-ms08-067',  # Conficker
                'ssl-heartbleed',     # Heartbleed
                'ssl-poodle',         # POODLE
                'ssl-ccs-injection',  # CCS Injection
                'http-shellshock',    # Shellshock
                'mysql-vuln-cve2012-2122',  # MySQL Auth Bypass
                'rdp-vuln-ms12-020'   # RDP DoS
            ],
            'high': [
                'smb-vuln-ms06-025', 'smb-vuln-ms07-029', 'smb-vuln-ms10-054',
                'smb-vuln-ms10-061', 'smb-vuln-conficker', 'http-sql-injection',
                'http-stored-xss', 'http-put', 'ftp-vsftpd-backdoor',
                'ftp-proftpd-backdoor', 'ssl-dh-params'
            ],
            'medium': [
                'http-trace', 'http-methods', 'http-unsafe-output-escaping',
                'ssl-cert-intaddr', 'ssl-known-key', 'ftp-anon',
                'telnet-encryption', 'vnc-info'
            ],
            'low': [
                'http-robots.txt', 'http-server-header', 'ssl-date',
                'ssh-hostkey', 'dns-recursion'
            ],
            'info': [
                'banner', 'http-title', 'http-headers', 'ssl-cert',
                'smb-os-discovery', 'ssh2-enum-algos'
            ]
        }
        
        # Credenciais padrão para teste
        self.default_credentials = {
            'ssh': [
                ('admin', 'admin'), ('root', 'root'), ('admin', 'password'),
                ('root', 'toor'), ('admin', ''), ('root', ''),
                ('user', 'user'), ('test', 'test'), ('guest', 'guest')
            ],
            'ftp': [
                ('anonymous', ''), ('ftp', 'ftp'), ('admin', 'admin'),
                ('user', 'user'), ('test', 'test')
            ],
            'telnet': [
                ('admin', 'admin'), ('root', 'root'), ('admin', 'password'),
                ('admin', ''), ('user', 'user')
            ],
            'http': [
                ('admin', 'admin'), ('admin', 'password'), ('root', 'root'),
                ('administrator', 'administrator'), ('admin', ''),
                ('user', 'user'), ('guest', 'guest')
            ],
            'smb': [
                ('administrator', 'administrator'), ('admin', 'admin'),
                ('guest', ''), ('user', 'user'), ('test', 'test')
            ],
            'snmp': [
                'public', 'private', 'community', 'manager', 'admin',
                'security', 'monitor', 'read', 'write'
            ]
        }
        
        # Configurações inseguras comuns
        self.insecure_configs = {
            'ssl_weak_ciphers': [
                'DES', 'RC4', 'MD5', 'SHA1', 'NULL', 'EXPORT'
            ],
            'http_dangerous_methods': [
                'PUT', 'DELETE', 'TRACE', 'CONNECT', 'OPTIONS'
            ],
            'weak_protocols': [
                'SSLv2', 'SSLv3', 'TLSv1.0'
            ]
        }
        
    def log(self, message):
        """Helper para logging"""
        if self.logger:
            self.logger.info(message)
        else:
            print(f"[INFO] {message}")
            
    def scan_all_vulnerabilities(self, target, timing='T4'):
        """Executa scan completo de vulnerabilidades"""
        self.log(f"Iniciando scan completo de vulnerabilidades para {target}")
        
        results = {}
        
        # Scan por categoria de severidade
        for severity, scripts in self.vulnerability_scripts.items():
            self.log(f"Executando scripts de severidade {severity}")
            severity_results = self._run_vulnerability_scripts(target, scripts, timing)
            results[severity] = severity_results
            
        # Testes de credenciais padrão
        self.log("Testando credenciais padrão")
        cred_results = self.test_default_credentials(target, timing)
        results['default_credentials'] = cred_results
        
        # Verificação de configurações inseguras
        self.log("Verificando configurações inseguras")
        config_results = self.check_insecure_configurations(target, timing)
        results['insecure_configs'] = config_results
        
        # Scan de vulnerabilidades web específicas
        self.log("Executando scan de vulnerabilidades web")
        web_results = self.scan_web_vulnerabilities(target, timing)
        results['web_vulnerabilities'] = web_results
        
        self.vulnerability_results[target] = results
        return results
        
    def scan_critical_vulnerabilities(self, target, timing='T4'):
        """Foca apenas em vulnerabilidades críticas"""
        self.log(f"Executando scan de vulnerabilidades CRÍTICAS para {target}")
        
        critical_scripts = self.vulnerability_scripts['critical']
        results = self._run_vulnerability_scripts(target, critical_scripts, timing)
        
        # Análise específica para vulnerabilidades críticas conhecidas
        critical_analysis = {}
        
        # EternalBlue (MS17-010)
        eternalblue_result = self._check_eternalblue(target, timing)
        if eternalblue_result:
            critical_analysis['eternalblue'] = eternalblue_result
            
        # Heartbleed
        heartbleed_result = self._check_heartbleed(target, timing)
        if heartbleed_result:
            critical_analysis['heartbleed'] = heartbleed_result
            
        # Shellshock
        shellshock_result = self._check_shellshock(target, timing)
        if shellshock_result:
            critical_analysis['shellshock'] = shellshock_result
            
        results['detailed_analysis'] = critical_analysis
        return results
        
    def test_default_credentials(self, target, timing='T4'):
        """Testa credenciais padrão em serviços comuns"""
        self.log(f"Testando credenciais padrão para {target}")
        
        cred_results = {}
        
        # SSH Brute Force
        ssh_creds = self.default_credentials['ssh']
        ssh_userlist = ','.join([cred[0] for cred in ssh_creds])
        ssh_passlist = ','.join([cred[1] for cred in ssh_creds])
        
        command = f"nmap --script ssh-brute --script-args userdb='{ssh_userlist}',passdb='{ssh_passlist}' -p 22 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            cred_results['ssh_brute'] = result
            
        # FTP Anonymous
        command = f"nmap --script ftp-anon,ftp-brute -p 21 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            cred_results['ftp_test'] = result
            
        # HTTP Basic Auth
        command = f"nmap --script http-brute --script-args http-brute.path=/admin/ -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            cred_results['http_brute'] = result
            
        # SMB Null Session
        command = f"nmap --script smb-enum-shares --script-args smbuser=guest,smbpass= -p 139,445 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            cred_results['smb_null'] = result
            
        # SNMP Community Strings
        for community in self.default_credentials['snmp']:
            command = f"nmap --script snmp-info --script-args snmpcommunity={community} -p 161 {target}"
            result = self._run_nmap_command(command, timing)
            if result and 'ERROR' not in result:
                cred_results[f'snmp_{community}'] = result
                
        return cred_results
        
    def check_insecure_configurations(self, target, timing='T4'):
        """Verifica configurações inseguras"""
        self.log(f"Verificando configurações inseguras para {target}")
        
        config_results = {}
        
        # SSL/TLS Configurações
        ssl_scripts = [
            'ssl-enum-ciphers', 'ssl-cert', 'ssl-date', 'ssl-dh-params',
            'sslv2', 'ssl-poodle', 'ssl-ccs-injection'
        ]
        
        for script in ssl_scripts:
            command = f"nmap --script {script} -p 443,8443 {target}"
            result = self._run_nmap_command(command, timing)
            if result:
                config_results[f'ssl_{script}'] = result
                
        # HTTP Methods perigosos
        command = f"nmap --script http-methods -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            config_results['http_methods'] = result
            
        # HTTP TRACE method
        command = f"nmap --script http-trace -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            config_results['http_trace'] = result
            
        # SMB Signing
        command = f"nmap --script smb-security-mode -p 139,445 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            config_results['smb_security'] = result
            
        # DNS Recursion
        command = f"nmap --script dns-recursion -p 53 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            config_results['dns_recursion'] = result
            
        return config_results
        
    def scan_web_vulnerabilities(self, target, timing='T4'):
        """Scan específico para vulnerabilidades web"""
        self.log(f"Executando scan de vulnerabilidades web para {target}")
        
        web_results = {}
        
        # SQL Injection
        command = f"nmap --script http-sql-injection --script-args http-sql-injection.url=/,http-sql-injection.method=GET -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['sql_injection'] = result
            
        # XSS
        command = f"nmap --script http-stored-xss,http-dombased-xss --script-args http-stored-xss.url=/ -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['xss'] = result
            
        # Directory Traversal
        command = f"nmap --script http-passwd,http-ls -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['directory_traversal'] = result
            
        # File Upload
        command = f"nmap --script http-put --script-args http-put.url=/uploads/test.txt,http-put.file=/etc/passwd -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['file_upload'] = result
            
        # Backup Files
        command = f"nmap --script http-backup-finder -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['backup_files'] = result
            
        # Git Exposure
        command = f"nmap --script http-git -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        if result:
            web_results['git_exposure'] = result
            
        return web_results
        
    def _check_eternalblue(self, target, timing):
        """Verificação específica para EternalBlue"""
        self.log("Verificando vulnerabilidade EternalBlue (MS17-010)")
        
        command = f"nmap --script smb-vuln-ms17-010 -p 139,445 {target}"
        result = self._run_nmap_command(command, timing)
        
        if result and 'VULNERABLE' in result:
            return {
                'vulnerable': True,
                'severity': 'CRITICAL',
                'description': 'Sistema vulnerável ao EternalBlue (MS17-010)',
                'impact': 'Execução remota de código como SYSTEM',
                'recommendation': 'Aplicar patch MS17-010 imediatamente',
                'raw_output': result
            }
        return None
        
    def _check_heartbleed(self, target, timing):
        """Verificação específica para Heartbleed"""
        self.log("Verificando vulnerabilidade Heartbleed")
        
        command = f"nmap --script ssl-heartbleed -p 443,8443 {target}"
        result = self._run_nmap_command(command, timing)
        
        if result and 'VULNERABLE' in result:
            return {
                'vulnerable': True,
                'severity': 'CRITICAL',
                'description': 'Sistema vulnerável ao Heartbleed (CVE-2014-0160)',
                'impact': 'Vazamento de memória, exposição de chaves privadas',
                'recommendation': 'Atualizar OpenSSL e regenerar certificados',
                'raw_output': result
            }
        return None
        
    def _check_shellshock(self, target, timing):
        """Verificação específica para Shellshock"""
        self.log("Verificando vulnerabilidade Shellshock")
        
        command = f"nmap --script http-shellshock --script-args uri=/cgi-bin/test.cgi -p 80,443,8080 {target}"
        result = self._run_nmap_command(command, timing)
        
        if result and 'VULNERABLE' in result:
            return {
                'vulnerable': True,
                'severity': 'CRITICAL',
                'description': 'Sistema vulnerável ao Shellshock (CVE-2014-6271)',
                'impact': 'Execução remota de comandos via CGI',
                'recommendation': 'Atualizar bash e desabilitar CGI desnecessários',
                'raw_output': result
            }
        return None
        
    def _run_vulnerability_scripts(self, target, scripts, timing):
        """Executa lista de scripts de vulnerabilidade"""
        results = {}
        
        for script in scripts:
            self.log(f"Executando script: {script}")
            
            # Determinar portas baseado no script
            if 'smb' in script:
                ports = '139,445'
            elif 'ssl' in script or 'https' in script:
                ports = '443,8443'
            elif 'http' in script:
                ports = '80,443,8080,8443'
            elif 'ssh' in script:
                ports = '22,2222'
            elif 'ftp' in script:
                ports = '21'
            elif 'rdp' in script:
                ports = '3389'
            elif 'mysql' in script:
                ports = '3306'
            else:
                ports = '1-65535'
                
            command = f"nmap --script {script} -p {ports} {target}"
            result = self._run_nmap_command(command, timing)
            
            if result:
                results[script] = result
                
                # Análise automática de resultados críticos
                if 'VULNERABLE' in result.upper():
                    self.log(f"VULNERABILIDADE ENCONTRADA: {script}")
                    
        return results
        
    def _run_nmap_command(self, command, timing):
        """Executa comando nmap com tratamento de erros"""
        try:
            # Delay aleatório para evitar detecção
            delay = random.uniform(1.0, 3.0)
            time.sleep(delay)
            
            result = subprocess.run(
                command.split(),
                capture_output=True,
                text=True,
                timeout=1200  # 20 minutos timeout
            )
            
            if result.returncode == 0:
                return result.stdout
            else:
                self.log(f"Erro no comando: {result.stderr}")
                return None
                
        except subprocess.TimeoutExpired:
            self.log("Timeout na execução do comando de vulnerabilidade")
            return None
        except Exception as e:
            self.log(f"Erro inesperado: {str(e)}")
            return None
            
    def parallel_vulnerability_scan(self, targets, max_workers=3):
        """Scan paralelo de vulnerabilidades para múltiplos targets"""
        self.log(f"Iniciando scan paralelo de vulnerabilidades para {len(targets)} targets")
        
        all_results = {}
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_target = {
                executor.submit(self.scan_all_vulnerabilities, target): target
                for target in targets
            }
            
            for future in future_to_target:
                target = future_to_target[future]
                try:
                    result = future.result(timeout=3600)  # 1 hora por target
                    all_results[target] = result
                except Exception as e:
                    self.log(f"Erro no scan de vulnerabilidades do target {target}: {str(e)}")
                    all_results[target] = {}
                    
        return all_results
        
    def generate_vulnerability_report(self, output_file):
        """Gera relatório detalhado de vulnerabilidades"""
        self.log("Gerando relatório de vulnerabilidades...")
        
        with open(output_file, 'w') as f:
            f.write("="*60 + "\n")
            f.write("RELATÓRIO DE VULNERABILIDADES\n")
            f.write("="*60 + "\n\n")
            f.write(f"Data/Hora: {datetime.now()}\n\n")
            
            for target, results in self.vulnerability_results.items():
                f.write(f"TARGET: {target}\n")
                f.write("="*40 + "\n\n")
                
                # Resumo executivo
                f.write("RESUMO EXECUTIVO:\n")
                f.write("-" * 20 + "\n")
                
                critical_count = 0
                high_count = 0
                medium_count = 0
                
                for severity, vuln_data in results.items():
                    if severity == 'critical' and vuln_data:
                        critical_count += len([v for v in vuln_data.values() if 'VULNERABLE' in str(v)])
                    elif severity == 'high' and vuln_data:
                        high_count += len([v for v in vuln_data.values() if 'VULNERABLE' in str(v)])
                    elif severity == 'medium' and vuln_data:
                        medium_count += len([v for v in vuln_data.values() if 'VULNERABLE' in str(v)])
                        
                f.write(f"Vulnerabilidades Críticas: {critical_count}\n")
                f.write(f"Vulnerabilidades Altas: {high_count}\n")
                f.write(f"Vulnerabilidades Médias: {medium_count}\n\n")
                
                # Detalhes por severidade
                for severity, vuln_data in results.items():
                    if vuln_data:
                        f.write(f"SEVERIDADE: {severity.upper()}\n")
                        f.write("-" * 30 + "\n")
                        
                        if isinstance(vuln_data, dict):
                            for vuln_name, vuln_output in vuln_data.items():
                                f.write(f"\nVulnerabilidade: {vuln_name}\n")
                                f.write("~" * 25 + "\n")
                                
                                if 'VULNERABLE' in str(vuln_output).upper():
                                    f.write("STATUS: VULNERÁVEL\n")
                                else:
                                    f.write("STATUS: Não vulnerável\n")
                                    
                                # Truncar output muito longo
                                output_str = str(vuln_output)
                                if len(output_str) > 500:
                                    f.write(output_str[:500] + "...\n")
                                else:
                                    f.write(output_str + "\n")
                        else:
                            f.write(str(vuln_data) + "\n")
                            
                        f.write("\n")
                        
                f.write("\n" + "="*60 + "\n\n")
                
        self.log(f"Relatório de vulnerabilidades salvo em: {output_file}")
        
    def export_results_json(self, output_file):
        """Exporta resultados em formato JSON"""
        self.log("Exportando resultados em JSON...")
        
        with open(output_file, 'w') as f:
            json.dump(self.vulnerability_results, f, indent=2, default=str)
            
        self.log(f"Resultados JSON salvos em: {output_file}")

