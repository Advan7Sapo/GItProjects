#!/usr/bin/env python3
"""

                >>> ADVAN7  Penetration Testing Scanner <<< 

 !!!Desenvolvido para pentesting autorizado em ambientes controlados!!!

Autor: ADVAN7 0fensive 5ecurity
Versão: 1.3
Data: 2025

                        AVISO LEGAL:

Este script deve ser usado APENAS em ambientes autorizados para testes de penetração.
O uso não autorizado pode violar leis locais e internacionais.
O usuário é responsável por garantir que possui autorização adequada.
"""

import argparse
import json
import xml.etree.ElementTree as ET
import subprocess
import sys
import os
import time
import datetime
import logging
from pathlib import Path
import threading
import queue
import re

# Importar módulos customizados
try:
    from reconnaissance_module import AdvancedReconnaissance
    from enumeration_module import AdvancedEnumeration
    from vulnerability_scanner import VulnerabilityScanner
    from reporting_module import AdvancedReporting
except ImportError as e:
    print(f"Erro ao importar módulos: {e}")
    print("Certifique-se de que todos os módulos estão no mesmo diretório.")
    sys.exit(1)

class AdvancedPentestScanner:
    """
    Scanner avançado para Pentest 
    Versão 1.3 com módulos integrados
    """
    
    def __init__(self):
        self.version = "1.3"
        self.start_time = datetime.datetime.now()
        self.results = {}
        self.target = None
        self.output_dir = None
        self.logger = None
        self.scan_queue = queue.Queue()
        
        # Configurações padrão
        self.default_ports = "1-65535"
        self.timing_template = "T4"
        self.max_threads = 50
        
        # Módulos especializados
        self.reconnaissance = None
        self.enumeration = None
        self.vulnerability_scanner = None
        self.reporting = None
        
    def setup_logging(self, output_dir):
        """Configura sistema de logging"""
        log_file = os.path.join(output_dir, f"pentest_scan_{self.start_time.strftime('%Y%m%d_%H%M%S')}.log")
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
        self.logger.info(f"ADVAN7  Pentest Scanner v{self.version} iniciado")
        self.logger.info(f"Target: {self.target}")
        
    def initialize_modules(self):
        """Inicializa todos os módulos especializados"""
        self.logger.info("Inicializando módulos especializados...")
        
        self.reconnaissance = AdvancedReconnaissance(self.logger)
        self.enumeration = AdvancedEnumeration(self.logger)
        self.vulnerability_scanner = VulnerabilityScanner(self.logger)
        self.reporting = AdvancedReporting(self.output_dir, self.logger)
        
        # Configurar metadados do relatório
        self.reporting.set_scan_metadata(
            target=self.target,
            pentester="ADV70f5ec",
            scan_type="Scan Completo"
        )
        
        self.logger.info("Módulos inicializados com sucesso!!!")
        
    def validate_target(self, target):
        """Valida se o target é válido"""
        # Regex básica para IP ou hostname
        ip_pattern = r'^(\d{1,3}\.){3}\d{1,3}(/\d{1,2})?$'
        hostname_pattern = r'^[a-zA-Z0-9.-]+$'
        
        if re.match(ip_pattern, target) or re.match(hostname_pattern, target):
            return True
        return False
        
    def create_output_directory(self, base_dir="pentest_results"):
        """Cria diretório de saída organizado"""
        timestamp = self.start_time.strftime('%Y%m%d_%H%M%S')
        output_dir = f"{base_dir}_{timestamp}"
        
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        # Criar subdiretórios
        subdirs = ['nmap_scans', 'reports', 'logs', 'screenshots', 'raw_data']
        for subdir in subdirs:
            Path(os.path.join(output_dir, subdir)).mkdir(exist_ok=True)
            
        return output_dir
        
    def phase_reconnaissance(self):
        """Fase 1: Reconhecimento avançado"""
        self.logger.info("=== FASE 1: RECONHECIMENTO ===")
        
        # Descoberta stealth de hosts
        discovered_hosts = self.reconnaissance.stealth_host_discovery(self.target, self.timing_template)
        
        # Técnicas de evasão de firewall
        evasion_results = self.reconnaissance.firewall_evasion_scan(self.target, self.timing_template)
        
        # Descoberta avançada de portas
        port_results = {}
        for host in discovered_hosts[:5]:  # Limitar a 5 hosts para não sobrecarregar
            ports = self.reconnaissance.advanced_port_discovery(host, self.timing_template)
            port_results[host] = ports
            
        # Fingerprinting de OS
        os_results = {}
        for host in discovered_hosts[:3]:  # Limitar a 3 hosts
            os_info = self.reconnaissance.os_fingerprinting_advanced(host, self.timing_template)
            os_results[host] = os_info
            
        # Salvar resultados
        recon_data = {
            'discovered_hosts': discovered_hosts,
            'evasion_results': evasion_results,
            'port_results': port_results,
            'os_results': os_results
        }
        
        self.results['reconnaissance'] = recon_data
        self.reporting.add_reconnaissance_data(recon_data)
        
        # Gerar relatório de reconhecimento
        recon_report_file = os.path.join(self.output_dir, "reports", "reconnaissance_report.txt")
        self.reconnaissance.generate_reconnaissance_report(recon_report_file)
        
        self.logger.info("Fase I CONCLUIDA !!!")
        return discovered_hosts
        
    def phase_enumeration(self, discovered_hosts):
        """Fase 2: Enumeração de serviços"""
        self.logger.info("=== FASE 2: ENUMERAÇÃO ===")
        
        enum_results = {}
        
        # Enumeração completa para cada host
        for host in discovered_hosts[:5]:  # Limitar hosts
            self.logger.info(f"Enumerando serviços para {host}")
            
            # Enumeração geral
            general_enum = self.enumeration.enumerate_all_services(host, self.timing_template)
            
            # Enumeração específica HTTP
            http_enum = self.enumeration.enumerate_http_services(host, timing=self.timing_template)
            
            # Enumeração específica SMB
            smb_enum = self.enumeration.enumerate_smb_services(host, self.timing_template)
            
            # Enumeração específica SSH
            ssh_enum = self.enumeration.enumerate_ssh_services(host, self.timing_template)
            
            # Enumeração de bancos de dados
            db_enum = self.enumeration.enumerate_database_services(host, self.timing_template)
            
            # Enumeração SNMP
            snmp_enum = self.enumeration.enumerate_snmp_services(host, self.timing_template)
            
            enum_results[host] = {
                'general': general_enum,
                'http': http_enum,
                'smb': smb_enum,
                'ssh': ssh_enum,
                'databases': db_enum,
                'snmp': snmp_enum
            }
            
        self.results['enumeration'] = enum_results
        self.reporting.add_enumeration_data(enum_results)
        
        # Gerar relatório de enumeração
        enum_report_file = os.path.join(self.output_dir, "reports", "enumeration_report.txt")
        self.enumeration.generate_enumeration_report(enum_report_file)
        
        self.logger.info("Fase II CONCLUIDA !!!")
        return enum_results
        
    def phase_vulnerability_assessment(self, discovered_hosts):
        """Fase 3: Avaliação de vulnerabilidades"""
        self.logger.info("=== FASE 3: AVALIAÇÃO DE VULNERABILIDADES ===")
        
        vuln_results = {}
        
        for host in discovered_hosts[:5]:  # Limitar hosts
            self.logger.info(f"Executando scan de vulnerabilidades para {host}")
            
            # Scan completo de vulnerabilidades
            complete_scan = self.vulnerability_scanner.scan_all_vulnerabilities(host, self.timing_template)
            
            # Scan focado em vulnerabilidades críticas
            critical_scan = self.vulnerability_scanner.scan_critical_vulnerabilities(host, self.timing_template)
            
            vuln_results[host] = {
                'complete_scan': complete_scan,
                'critical_scan': critical_scan
            }
            
        self.results['vulnerabilities'] = vuln_results
        self.reporting.add_vulnerability_data(vuln_results)
        
        # Gerar relatório de vulnerabilidades
        vuln_report_file = os.path.join(self.output_dir, "reports", "vulnerability_report.txt")
        self.vulnerability_scanner.generate_vulnerability_report(vuln_report_file)
        
        # Exportar em JSON
        vuln_json_file = os.path.join(self.output_dir, "reports", "vulnerabilities.json")
        self.vulnerability_scanner.export_results_json(vuln_json_file)
        
        self.logger.info("Fase III CONCLUIDA !!!")
        return vuln_results
        
    def phase_reporting(self):
        """Fase 4: Geração de relatórios"""
        self.logger.info("=== FASE 4: GERAÇÃO DE RELATÓRIOS ===")
        
        # Gerar relatórios em múltiplos formatos
        reports_generated = []
        
        # Relatório HTML
        html_report = self.reporting.generate_html_report("pentest_report.html")
        reports_generated.append(html_report)
        
        # Relatório JSON
        json_report = self.reporting.generate_json_report("pentest_report.json")
        reports_generated.append(json_report)
        
        # Relatório XML
        xml_report = self.reporting.generate_xml_report("pentest_report.xml")
        reports_generated.append(xml_report)
        
        # Resumo CSV
        csv_report = self.reporting.generate_csv_summary("vulnerability_summary.csv")
        reports_generated.append(csv_report)
        
        # Criar arquivo compactado
        archive_file = self.reporting.create_archive("pentest_complete_results.zip")
        reports_generated.append(archive_file)
        
        self.logger.info("Fase de geração de relatórios concluída")
        return reports_generated
        
    def run_full_scan(self, target, scan_mode="complete"):
        """Executa scan completo"""
        if not self.validate_target(target):
            self.logger.error("Target inválido")
            return False
            
        self.target = target
        self.output_dir = self.create_output_directory()
        self.setup_logging(self.output_dir)
        self.initialize_modules()
        
        try:
            # Executar todas as fases
            self.logger.info(f"Iniciando scan {scan_mode} para {target}")
            
            # Fase 1: Reconhecimento
            discovered_hosts = self.phase_reconnaissance()
            
            if not discovered_hosts:
                self.logger.warning("Nenhum host descoberto. Continuando com target original.")
                discovered_hosts = [target]
                
            # Fase 2: Enumeração
            if scan_mode in ["complete", "enumeration"]:
                enum_results = self.phase_enumeration(discovered_hosts)
                
            # Fase 3: Vulnerabilidades
            if scan_mode in ["complete", "vulnerabilities"]:
                vuln_results = self.phase_vulnerability_assessment(discovered_hosts)
                
            # Fase 4: Relatórios
            reports = self.phase_reporting()
            
            # Estatísticas finais
            end_time = datetime.datetime.now()
            duration = end_time - self.start_time
            
            self.logger.info(f"Scan completo finalizado em {duration}")
            self.logger.info(f"Hosts descobertos: {len(discovered_hosts)}")
            self.logger.info(f"Relatórios gerados: {len(reports)}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante o scan: {str(e)}")
            return False
            
    def run_quick_scan(self, target):
        """Executa scan rápido focado em vulnerabilidades críticas"""
        if not self.validate_target(target):
            self.logger.error("Target inválido")
            return False
            
        self.target = target
        self.output_dir = self.create_output_directory("quick_scan_results")
        self.setup_logging(self.output_dir)
        self.initialize_modules()
        
        try:
            self.logger.info(f"Iniciando scan rápido para {target}")
            
            # Descoberta básica de hosts
            discovered_hosts = self.reconnaissance.stealth_host_discovery(target, "T5")  # Timing agressivo
            
            if not discovered_hosts:
                discovered_hosts = [target]
                
            # Scan apenas de vulnerabilidades críticas
            vuln_results = {}
            for host in discovered_hosts[:3]:  # Máximo 3 hosts
                critical_vulns = self.vulnerability_scanner.scan_critical_vulnerabilities(host, "T5")
                vuln_results[host] = critical_vulns
                
            self.results['vulnerabilities'] = vuln_results
            self.reporting.add_vulnerability_data(vuln_results)
            
            # Gerar apenas relatório JSON
            json_report = self.reporting.generate_json_report("quick_scan_report.json")
            
            self.logger.info("Scan rápido finalizado")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro durante o scan rápido: {str(e)}")
            return False

def main():
    """Função principal"""
    parser = argparse.ArgumentParser(
        description="ADVAN7 Penetration Testing Scanner v1.3",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos de uso:
  python3 advanced_pentest_scanner.py -t 192.168.1.1
  python3 advanced_pentest_scanner.py -t 192.168.1.0/24 --mode complete
  python3 advanced_pentest_scanner.py -t example.com --mode quick
  python3 advanced_pentest_scanner.py -t 10.0.0.1 --timing T3 --mode vulnerabilities
        """
    )
    
    parser.add_argument('-t', '--target', required=True,
                       help='Target IP, hostname ou rede (ex: 192.168.1.1 ou 192.168.1.0/24)')
    parser.add_argument('-o', '--output', default='pentest_results',
                       help='Diretório base para saída (default: pentest_results)')
    parser.add_argument('--timing', choices=['T0', 'T1', 'T2', 'T3', 'T4', 'T5'],
                       default='T4', help='Template de timing do nmap (default: T4)')
    parser.add_argument('--mode', choices=['complete', 'quick', 'reconnaissance', 'enumeration', 'vulnerabilities'],
                       default='complete', help='Modo de scan (default: complete)')
    parser.add_argument('--no-confirm', action='store_true',
                       help='Pular confirmação de autorização (use com cuidado)')
    
    args = parser.parse_args()
    
    # Banner
    print("="*70)
    print("ADVAN7 PENTESTING SCANNER v1.3")
    print("Para uso APENAS em ambientes autorizados")
    print("Desenvolvido por ADVAN7 0fensive 5ecurity")
    print("="*70)
    
    # Confirmação de autorização
    if not args.no_confirm:
        response = input("Você possui autorização para testar este target? (sim/não): ")
        if response.lower() not in ['sim', 's', 'yes', 'y']:
            print("Operação cancelada. Use apenas em ambientes autorizados.")
            sys.exit(1)
    
    # Inicializar scanner
    scanner = AdvancedPentestScanner()
    scanner.timing_template = args.timing
    
    # Executar scan baseado no modo
    if args.mode == "quick":
        success = scanner.run_quick_scan(args.target)
    else:
        success = scanner.run_full_scan(args.target, args.mode)
    
    if success:
        print(f"\nScan concluído! Resultados salvos em: {scanner.output_dir}")
        print("\nArquivos principais gerados:")
        print(f"- Relatório HTML: {scanner.output_dir}/reports/pentest_report.html")
        print(f"- Dados JSON: {scanner.output_dir}/reports/pentest_report.json")
        print(f"- Arquivo compactado: {scanner.output_dir}/pentest_complete_results.zip")
    else:
        print("\nErro durante a execução do scan.")
        sys.exit(1)

if __name__ == "__main__":
    main()

